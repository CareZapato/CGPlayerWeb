generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String             @id @default(cuid())
  email                 String             @unique
  username              String             @unique
  password              String
  firstName             String
  lastName              String
  phone                 String?
  isActive              Boolean            @default(true)
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  locationId            String?
  lyricContributions    Lyric[]
  playlists             Playlist[]
  soloPerformances      Soloist[]
  songAssignments       SongAssignment[]
  songUploads           Song[]             @relation("SongUploader")
  assignedRoles         UserRole_DB[]      @relation("RoleAssignments")
  roles                 UserRole_DB[]      @relation("UserRoles")
  assignedVoiceProfiles UserVoiceProfile[] @relation("VoiceAssignments")
  voiceProfiles         UserVoiceProfile[] @relation("UserVoiceProfiles")
  location              Location?          @relation(fields: [locationId], references: [id])

  @@map("users")
}

model UserRole_DB {
  id             String   @id @default(cuid())
  userId         String
  role           UserRole
  assignedBy     String?
  createdAt      DateTime @default(now())
  assignedByUser User?    @relation("RoleAssignments", fields: [assignedBy], references: [id])
  user           User     @relation("UserRoles", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, role])
  @@map("user_roles")
}

model UserVoiceProfile {
  id             String    @id @default(cuid())
  userId         String
  voiceType      VoiceType
  assignedBy     String?
  createdAt      DateTime  @default(now())
  assignedByUser User?     @relation("VoiceAssignments", fields: [assignedBy], references: [id])
  user           User      @relation("UserVoiceProfiles", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, voiceType])
  @@map("user_voice_profiles")
}

model Song {
  id            String           @id @default(cuid())
  title         String
  artist        String?
  album         String?
  duration      Int?
  fileName      String
  filePath      String
  fileSize      Int
  mimeType      String
  uploadedBy    String
  isActive      Boolean          @default(true)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  genre         String?
  parentSongId  String?
  voiceType     VoiceType?
  coverColor    String?
  folderName    String?
  eventSongs    EventSong[]
  lyrics        Lyric[]
  playlistItems PlaylistItem[]
  soloists      Soloist[]
  assignments   SongAssignment[]
  parentSong    Song?            @relation("SongVersions", fields: [parentSongId], references: [id])
  childVersions Song[]           @relation("SongVersions")
  uploader      User             @relation("SongUploader", fields: [uploadedBy], references: [id])

  @@map("songs")
}

model SongAssignment {
  id        String    @id @default(cuid())
  songId    String
  userId    String
  voiceType VoiceType
  createdAt DateTime  @default(now())
  song      Song      @relation(fields: [songId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([songId, userId, voiceType])
  @@map("song_assignments")
}

model Playlist {
  id          String         @id @default(cuid())
  name        String
  description String?
  userId      String
  voiceType   VoiceType?
  isPublic    Boolean        @default(false)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  items       PlaylistItem[]
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("playlists")
}

model PlaylistItem {
  id         String   @id @default(cuid())
  playlistId String
  songId     String
  order      Int
  createdAt  DateTime @default(now())
  playlist   Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  song       Song     @relation(fields: [songId], references: [id], onDelete: Cascade)

  @@unique([playlistId, order])
  @@map("playlist_items")
}

model Lyric {
  id        String     @id @default(cuid())
  songId    String
  content   String
  timestamp Float?
  voiceType VoiceType?
  createdBy String
  isActive  Boolean    @default(true)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  creator   User       @relation(fields: [createdBy], references: [id])
  song      Song       @relation(fields: [songId], references: [id], onDelete: Cascade)

  @@map("lyrics")
}

model Location {
  id        String       @id @default(cuid())
  name      String
  type      LocationType
  address   String?
  city      String
  region    String?
  country   String       @default("Chile")
  isActive  Boolean      @default(true)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  color     String?
  phone     String?
  events    Event[]
  users     User[]

  @@map("locations")
}

model Event {
  id          String      @id @default(cuid())
  title       String
  description String?
  date        DateTime
  locationId  String?
  category    String?
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  eventSongs  EventSong[]
  location    Location?   @relation(fields: [locationId], references: [id])
  soloists    Soloist[]

  @@map("events")
}

model EventSong {
  id      String  @id @default(cuid())
  eventId String
  songId  String
  order   Int
  notes   String?
  event   Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  song    Song    @relation(fields: [songId], references: [id], onDelete: Cascade)

  @@unique([eventId, order])
  @@map("event_songs")
}

model Soloist {
  id          String      @id @default(cuid())
  eventId     String
  userId      String
  songId      String?
  soloistType SoloistType
  notes       String?
  createdAt   DateTime    @default(now())
  event       Event       @relation(fields: [eventId], references: [id], onDelete: Cascade)
  song        Song?       @relation(fields: [songId], references: [id])
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("soloists")
}

enum UserRole {
  ADMIN
  CANTANTE
  DIRECTOR
}

enum VoiceType {
  SOPRANO
  CONTRALTO
  TENOR
  BARITONO
  MESOSOPRANO
  BAJO
  CORO
  ORIGINAL
}

enum SoloistType {
  MALE
  FEMALE
  BOTH
}

enum LocationType {
  ANTOFAGASTA
  VINA_DEL_MAR
  SANTIAGO
  CONCEPCION
  VALDIVIA
  TODOS_LOS_CORISTAS
}
